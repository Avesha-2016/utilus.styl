// Simple shortcut to check if the argument is an array
utilus_is_array()
  return length(arguments) > 1

is_array ?= utilus_is_array

// Simple shortcut to check if the argument is a hash
utilus_is_hash()
  return false unless utilus_is_array(arguments)

  for $item in arguments
    return true if utilus_is_array($item)

  return false

is_hash ?= utilus_is_hash


// Simple shortcut to check if the arguments are separated by comma
utilus_is_comma_list()
  return false unless utilus_is_array(arguments)

  for $item, $index in arguments
    if $index == 0
      $test = $item
    else
      $test = $test, $item
  return s('%s',arguments) == s('%s',$test)

is_comma_list ?= utilus_is_comma_list

use('is_function.js')
utilus_is_function($function_name)
  return _utilus_is_function($function_name)

is_function ?= utilus_is_function

// Stylus don't allow us to reassign global variables in functions, so I made this:
//   `reassign($foo,"new")` is like `$foo = "new"`, but now works in functions, yays!
// However, you need to use this variable like `clone($var)`, or it would get the ressigned value everywhere
utilus_reassign($where, $what)
  $where[0] = '' // So if there is a multidimensional array, the pop would pop the appropriate item at last
  for i in $where
    $void = pop($where)
  push($where,$what)

reassign ?= utilus_reassign


// Proxy for throwing arguments into some function
utilus_proxy(func, args...)
  // If we get a single nested array, make it not nested
  if length(args) == 1
    args = args[0]

  if length(args) == 1
    func(args)
  else if length(args) == 2
    func(args[0],args[1])
  else if length(args) == 3
    func(args[0],args[1],args[2])
  else if length(args) == 4
    func(args[0],args[1],args[2],args[3])
  else if length(args) == 5
    func(args[0],args[1],args[2],args[3],args[4])
  else if length(args) == 6
    func(args[0],args[1],args[2],args[3],args[4],args[5])
  else if length(args) == 7
    func(args[0],args[1],args[2],args[3],args[4],args[5],args[6])

proxy ?= utilus_proxy


// Proper append the given array with given item
utilus_append($first, $second, $use_comma = auto)
  $result = clone($first)

  if length($first) == 0
    $result = $second
  else
    if $use_comma != false
      if utilus_is_comma_list($first) or (!utilus_is_array($second) and $use_comma != true)
        push($result, $second)
      else
        $result = $first, $second
        $result[0] = $first
        $result[1] = $second
    else
      if utilus_is_comma_list($first)
        push($result[length($result) - 1], $second)
      else
        push($result, $second)

  return $result


// Prepend the given array with given value
utilus_prepend($where, $what, $use_comma = auto)
  $result = $what
  if utilus_is_comma_list($where)
    for $item, $index in $where
      if $index == 0 and $use_comma == false
        $result = $result $item
      else
        $result = $result, $item
  else
    for $item, $index in $where
      if $index == 0 and $use_comma == true
        $result = $result, $item
      else
        $result = $result $item
  return $result


// Remove the first item, return the original array.
utilus_remove_first($where)
  $result = unquote('')
  if utilus_is_comma_list($where)
    for $item, $index in $where
      if $index == 1
        $result = $item
      else if $index > 1
        $result = $result, $item
  else
    for $item, $index in $where
      push($result, $item) if $index > 0
  return $result

remove_first ?= utilus_remove_first


// Do some func on every item of the given argument (second)
utilus_mass(func, args...)
  what = args[0]
  if !utilus_is_array(what)
    what = utilus_proxy(func, args)
  else
    for w,i in what
      newargs = arguments
      newargs[1] = w
      what[i] = utilus_proxy(mass, newargs)
  return what

mass ?= utilus_mass


// Returns first defined variable or entity, false otherwise
//   predefined arguments are needed so the function would
//   return an array if it's the only argument
utilus_or($arg1, $arg2 = false, args...)
  for $arg in arguments
    return $arg if $arg != false and (typeof($arg) != 'ident' or utilus_is_array($arg) or $arg == 0)
  return false

// or ?= utilus_or


// Flatten nested arrays to a flat one-level array
// Use as
//   a: flatten(1..5, 7..10, 14..15, 17..18)
//   a: flatten(1..5 7..10 14..15 17..18)

utilus_flatten()
  result = ()

  compute()
    for arg in arguments
      if length(arg) > 1
        compute(arg)
      else
        push(result, arg)

  compute(arguments)
  return result

flatten ?= utilus_flatten


utilus_ident($what)
  if type($what) == 'function'
    return '%s' % $what
  else
    return $what

// Hash getter with possible fallback.
// Returns `false` if nothing found, or no `fallback` given
utilus_get($hash, $keys = false, $fallback = false)
  if type($hash) == 'object'
    return $hash['' + utilus_ident($keys)] || $fallback

  if utilus_ident($hash[0]) == 'any'
    $any_result = false
    $hash = utilus_remove_first($hash)
    for $where in $hash
      unless $any_result
        $any_result = utilus_get($where, $keys, $fallback)
    return $any_result
  else
    if utilus_is_array($keys)
      $key = pop($keys)
      for $subkey in $keys
        $hash = utilus_get($hash, $subkey)
    else
      $key = $keys

    $key = utilus_ident($key)
    $result = false
    if utilus_is_array($hash) and $key
      if utilus_is_hash($hash)
        for $pair in $hash
          if $result == false and type($result) == 'boolean'
            if utilus_is_array($pair)
              $result = $pair[1..length($pair)] if utilus_ident($pair[0]) == $key
            else
              $result = true if utilus_ident($pair) == $key
      else
        if utilus_is_comma_list($hash)
          for $item in $hash
            $result = true if utilus_ident($item) == $key
        else
          $result = $hash[1..length($hash)] if utilus_ident($hash[0]) == $key

    if $result == null
      $result = true
    if $result == false and type($result) == 'boolean'
      $result = $fallback

    return $result
    // What if hash contains multiple items with the same key?

get ?= utilus_get

$utilus_collect_by_type_cache = {}
utilus_collect_by_type($where)
  if ('' + $where) in $utilus_collect_by_type_cache
    return $utilus_collect_by_type_cache['' + $where]

  $result = {
    strings: (),
    idents: (),
    units: (),
    rgbas: (),
    booleans: (),
    functions: (),
    objects: (),
    arrays: ()
  }

  for $item in $where
    if length($item) > 1 and type($item) != 'object'
      push($result['arrays'], $item)
    else
      push($result[type($item) + 's'], $item)

  $result['colors'] = $result['rgbas']

  $utilus_collect_by_type_cache['' + $where] = $result
  return $result

collect_by_type ?= utilus_collect_by_type


// Getter of an argument at the given index
//   Should it be merged with either simple `get` or `or`?
utilus_get_n($where, $fallback = false, $index = 0, $type = 'any')
  if $type == 'any'
    return $where[$index] || $fallback
  else
    return utilus_collect_by_type($where)[$type + 's'][$index] || $fallback

get_n ?= utilus_get_n

utilus_get_string($where, $fallback = false, $index = 0)
  return utilus_collect_by_type($where)['strings'][$index] || $fallback

get_string ?= utilus_get_string

utilus_get_ident($where, $fallback = false, $index = 0)
  return utilus_collect_by_type($where)['idents'][$index] || $fallback

get_ident ?= utilus_get_ident

utilus_get_unit($where, $fallback = false, $index = 0)
  return utilus_collect_by_type($where)['units'][$index] || $fallback

get_unit ?= utilus_get_unit

utilus_get_color($where, $fallback = false, $index = 0)
  return utilus_collect_by_type($where)['rgbas'][$index] || $fallback

get_color ?= utilus_get_color


// Get the item from arguments with the same type of the given fallback
utilus_alike($where, $fallback, $index = 0)
  $result = utilus_collect_by_type($where)[type($fallback) + 's'][$index]
  return $result if type($result == 'boolean') and $result == false
  return $result || ($fallback)

alike ?= utilus_alike


// Retrieve one of the given items with optional fallback
utilus_retrieve($where, $what, $fallback = false)
  if utilus_is_array($what)
    if type($where) == 'object'
      for $what_item in $what
        if $what_item in $where
          if type($where[''+$what_item]) == 'boolean' and $where[''+$what_item] == true
            return $what_item
          else
            return $where[''+$what_item]
    else
      for $what_item in $what
        if $what_item in $where
          return $what_item
  else
    if $what in $where
      return $what
  return $fallback

retrieve ?= utilus_retrieve


// Count the arguments by the given type
utilus_count($where, $what = 'unit')
  $count = 0
  for $item in $where
    if type($item) == $what
      $count = $count + 1
  return $count

count ?= utilus_count


// retrieve the sides array, like in paddings, margins, borders etc.
utilus_get_sides($where, $fallback = 0)
  // Could be refactored to have only one for running
  $found_units = utilus_collect_by_type($where).units
  if !length($found_units)
    $found_units = $fallback $fallback $fallback $fallback
  else if length($found_units) == 1
    $found_units[$i] = $found_units[0] for $i in 1..3
  else if length($found_units) == 2
    $found_units[2] = $found_units[0]
    $found_units[3] = $found_units[1]
  else if length($found_units) == 3
    $found_units[3] = $found_units[1]

  // Could use `auto` from arguments instead of using `trbl` keywords
  $found_units[0] = auto if bottom in $where
  $found_units[1] = auto if left in $where
  $found_units[2] = auto if top in $where
  $found_units[3] = auto if right in $where

  return $found_units

get_sides ?= utilus_get_sides


/* Color functions
========================================*/

// Transparentify a color
// Inspiration: https://github.com/LearnBoost/stylus/issues/313
// Use as
//   color: rgb2rgba(#CC6699)
utilus_rgb2rgba(color, underlay = #FFF)
  r1 = red(color)
  g1 = green(color)
  b1 = blue(color)

  r2 = red(underlay)
  g2 = green(underlay)
  b2 = blue(underlay)

  a1 = a2 = a3 = abs(r1 - r2) / 255 if r1 != r2

  a1 = abs(r1 - r2) / (255 - r2) if not r2 in (r1 255)
  a2 = abs(g1 - g2) / (255 - g2) if not g2 in (g1 255)
  a3 = abs(b1 - b2) / (255 - b2) if not b2 in (b1 255)

  a = min(a1,min(a2,a3))

  r = r2 + (r1 - r2) / floor(a, 2)
  g = g2 + (g1 - g2) / floor(a, 2)
  b = b2 + (b1 - b2) / floor(a, 2)

  a = round(a, 2)

  return rgba(r,g,b,a)

rgb2rgba ?= utilus_rgb2rgba

// Alias
transparentify ?= utilus_rgb2rgba


// Getting luminance of a color,
//   got from https://github.com/LeaVerou/contrast-ratio/blob/gh-pages/color.js#L55
utilus_luminance($color)
  f($c)
    $c = $c / 255
    return ($c < 0.03928) ? ($c / 12.92) : (($c + 0.055) / 1.055) ** 2.4;
  return 0.2126 * f(red($color)) + 0.7152 * f(green($color)) + 0.0722 * f(blue($color));

luminance ?= utilus_luminance


// Get just the average color from the given colors.
utilus_average_color()
  $l = length(arguments)
  $r = 0
  $g = 0
  $b = 0
  $a = 0

  for $color in arguments
    $r = $r + red($color)
    $g = $g + green($color)
    $b = $b + blue($color)
    $a = $a + alpha($color)

  $r = $r / $l
  $g = $g / $l
  $b = $b / $l
  $a = $a / $l

  return rgba($r,$g,$b,$a)

average_color ?= utilus_average_color


// Basic color blending
utilus_blend($top,$bottom = #FFF)
  // Only normal blending here for now
  return $top if alpha($top) == 1
  return $bottom if alpha($top) == 0

  newR = (1 - alpha($top)) *   red($bottom) + alpha($top) *   red($top)
  newG = (1 - alpha($top)) * green($bottom) + alpha($top) * green($top)
  newB = (1 - alpha($top)) *  blue($bottom) + alpha($top) *  blue($top)
  newA = 1 // FIXME: should be smth different if the alpha of $bottom != 1

  return rgba(newR,newG,newB,newA)

blend ?= utilus_blend


// Determining contrast ratio,
//   based on https://github.com/LeaVerou/contrast-ratio/blob/gh-pages/color.js#L108
//       .. 3   == bad for any text
//   3   .. 4.5 == bad for small text
//   4.5 .. 7   == perfect for big text
//   7   ..     == perfect for any size
utilus_contrast($top,$bottom = #FFF)
  if alpha($bottom) >= 1
    $l1 = utilus_luminance($bottom) + .05
    $l2 = utilus_luminance( alpha($top) < 1 ? utilus_blend($top,$bottom) : $top ) + .05
    $ratio = $l1 / $l2
    if $l2 > $l1
      $ratio = 1 / $ratio
    return round($ratio,1)
  else
    // FIXME: some minor difference there with http://leaverou.github.com/contrast-ratio/
    $closest = \
      rgb(min(max(0, (red($top)   - red($bottom)   * alpha($bottom)) / (1 - alpha($bottom))),255), \
          min(max(0, (green($top) - green($bottom) * alpha($bottom)) / (1 - alpha($bottom))),255), \
          min(max(0, (blue($top)  - blue($bottom)  * alpha($bottom)) / (1 - alpha($bottom))),255))
    $max = max(utilus_contrast($top,utilus_blend($bottom,#FFF)),utilus_contrast($top,utilus_blend($bottom,#000)))
    $min = utilus_contrast($top,$closest)
    return (round(($min + $max) / 2, 2) $min $max)

contrast ?= utilus_contrast
